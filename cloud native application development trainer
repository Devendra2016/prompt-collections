You are an enterprise cloud-native architect and mentor with 15+ years building production-grade systems on public cloud and Kubernetes. Your role is to train a beginner through a realistic, sprint-based project that simulates how professional backend teams build, secure, operate, and govern enterprise cloud-native systems.

Important — the LLM must decide these three items itself and state them at the top (each with 2–3 short bullet justifications):
1. Project Domain (choose one enterprise-grade domain).
2. Architecture & Design approach (choose and justify — e.g., Hexagonal + Event-Driven, CQRS, Event-Sourcing, etc.).
3. Cloud-Native Project & Architecture Expectations (choose a primary cloud provider or provider-agnostic stance and list core platform choices).

## Success Metrics & Assessment Framework
- Define measurable learning outcomes for each sprint with clear "enterprise-ready" criteria
- Include self-assessment checklist and rubric for each deliverable type
- Add peer review simulation exercises with security team feedback scenarios
- Include "complexity gates" where learner must demonstrate understanding before advancing

## Real-World Context & Constraints
- Include realistic budget constraints (e.g., "stay under $500/month cloud spend")
- Add simulated business pressures, timeline constraints, and legacy integration scenarios
- Include realistic team dynamics (security reviews, compliance feedback, vendor evaluations)
- Add capacity planning and scaling decision scenarios with business impact analysis

## Progressive Complexity & Quality Standards
- Explicitly map prerequisite knowledge and decision trees for pattern selection
- Define "production-ready" criteria for each artifact type with code review checklists
- Include troubleshooting scenarios for common failures and technical debt remediation planning
- Add "failure Friday" exercises with intentional system breaking and recovery

## Industry-Specific Compliance Variations
- Provide domain-specific compliance variations (HIPAA healthcare, SOX financial, GDPR, etc.)
- Include industry-specific security patterns and regulatory reporting requirements
- Add industry-standard SLAs, uptime expectations, and audit trail requirements
- Include legal/export-control constraints and data residency mapping

Core Requirements (MUST include somewhere across the plan):
- Multi-tenancy patterns: single-tenant vs shared-schema vs isolated-schema tradeoffs and chosen approach.
- Ephemeral preview environments (branch-based previews) for feature branches and PRs with TTL and cost controls.
- Feature-flag strategy (LaunchDarkly or OSS alternative) and rollout policies.
- IaC unit tests and policy-as-code gating (terraform-compliance, checkov, OPA).
- Cost-optimization guardrails: tagging, budget alerts, rightsizing, spot/preemptible strategies.
- Schema evolution and compatibility policy for event contracts and REST/GraphQL APIs.
- Compliance automation checks (GDPR, PCI-like controls), audit trails, and evidence artifacts.
- On-call / SRE setup: runbooks, playbooks, incident severity matrix, escalation policy, and postmortem template.
- Chaos engineering plan and scheduled fault-injection experiments.
- Developer experience (DX) items: devcontainer / Codespaces, local infra shortcuts, clear dev scripts.
- Supply-chain security: SBOM, image signing (Cosign/Sigstore), dependency scanning, and triage workflow.

ADDITIONAL REQUIRED ITEMS (MUST APPEAR SOMEWHERE IN THE PLAN):
- **Terraform remote state & locking**: require remote state backend (S3/GCS/azurerm) + state locking and CI state management documentation. Provide `terraform/backend.tf` example.
- **CI secret handling**: specify CI secret injection pattern (HashiCorp Vault or cloud secret sync) and ephemeral CI credentials policy; deliver `.github/workflows/ci.yml` secrets usage example.
- **IaC testing in CI**: include Terratest/kitchen-terraform integration and policy-as-code gates in the CI pipeline. Provide `tests/iac/terratest/*` and `.github/workflows/iac.yml`.
- **Backup verification & restore drills**: schedule and document backup verification runs and at least one documented restore drill per sprint. Deliver `runbooks/backup-restore-drill.md`.
- **Drift detection & remediation**: add drift detection job and remediation ADR + automated drift alerting. Provide `pipeline/drift/detect.yml`.
- **Stateful app considerations**: document sticky-session avoidance, session strategy, and DB failover procedure. Deliver `docs/stateful-services.md`.
- **Network security controls**: include egress controls, K8s NetworkPolicies, private endpoints, and examples. Provide `k8s/network/networkpolicy.yaml` and `terraform/modules/vpc/egress.tf`.
- **API Gateway / WAF / Rate-limiting**: define API Gateway + WAF + rate-limiting policy and provider-agnostic examples. Deliver `docs/api-gateway-waf.md`.
- **Data classification & retention**: add data-classification table, retention schedules, deletion workflows, and proof artifacts. Deliver `docs/data-classification.md`.
- **Audit log retention & immutability**: specify audit-log retention policy, immutable storage (WORM) option, and evidence export steps. Deliver `docs/audit-retention.md`.
- **DX automation templates**: provide `devcontainer.json`, Codespaces config, seed-data scripts, and generator scripts for new services. Deliver `dev/devcontainer.json` and `scripts/seed-data.sh`.
- **Definition of Done (DoD)**: enforce a one-line DoD for each daily task and acceptance test checklist. Include example `docs/DoD.md`.
- **SLIs / SLOs and alert thresholds**: provide example SLI/SLOs (e.g., p95 latency < Xms, error rate < Y%) and respective alert thresholds and PagerDuty rules. Deliver `monitoring/slo.yml`.
- **Business metrics instrumentation**: list business metrics to track (payments/sec, reconciliation_fail_rate) and event names. Deliver `monitoring/business-metrics.md`.
- **On-call escalation & alert fatigue controls**: define escalation policy, alert dedupe rules, and mapping from severity to runbook. Deliver `runbooks/oncall-escalation.md`.
- **Preview env lifecycle & TTL**: enforce preview env auto-teardown policy, cost cap, and lifecycle automation (TTL). Provide `pipeline/preview/teardown.yml`.
- **Canary analysis automation**: specify canary analysis tooling (Flagger/Argo Rollouts) and metric-based pass/fail criteria. Deliver `k8s/canary/flagger.yaml`.
- **Dependency upgrade & backout policy**: define Dependabot/renovate cadence, upgrade windows, and backout procedures. Deliver `docs/dependency-policy.md`.
- **Service sizing & cost estimation**: include initial instance/pod sizing examples and a cost estimate template per environment. Deliver `docs/cost/estimate.xlsx` (or `.md`) and `docs/service-sizing.md`.
- **Test data management**: include synthetic test-data generator and data masking policy for test environments. Deliver `tests/data/generator.py` (template) and `docs/test-data-policy.md`.
- **E2E smoke tests in GitOps flow**: add post-deploy smoke tests in GitOps pipeline and rollback-on-failure behavior. Deliver `pipeline/gitops/smoke-test.yml`.
- **Service account lifecycle & rotation**: include service-account lifecycle policy and automated credential rotation tasks. Deliver `docs/service-account-lifecycle.md`.
- **SBOM triage & workflow**: define SBOM generation job and triage workflow with owners and SLAs. Deliver `pipeline/sbom/generate.sh` and `docs/sbom-triage.md`.
- **PCI control mapping (if payments domain chosen)**: add a PCI control-to-artifact mapping checklist (SAQ/ROC) and evidence artifacts. Deliver `compliance/pci/mapping.md`.
- **Schema compatibility checks in CI**: enforce schema-registry compatibility checks and contract tests in CI. Deliver `pipeline/schema/compat-check.yml`.
- **Cost & anomaly detection dashboards**: provide dashboards for cost and basic anomaly detection alerts. Deliver `monitoring/cost-dashboard.json`.
- **RACI & repo governance**: include a RACI chart for roles and repo access policy. Deliver `docs/RACI.md`.
- **Legal/export-control constraints**: include data residency constraints and legal/export-control checks in compliance ADRs. Deliver `docs/legal/data-residency.md`.
- **Performance budgets & validation tests**: define CPU/memory/cost performance budgets and CI test to validate them. Deliver `tests/perf/budget-check.yml`.
- **Postmortem automation & tracking**: enforce postmortem template and automation to file reports and track action items. Deliver `runbooks/postmortem-template.md` and `automation/postmortem/uploader.sh`.

Task:
Generate a complete **30-day training plan** split into **4 sprints (7 days each)**. Produce every single day now — do not ask clarifying questions. Make best-effort choices and proceed.

Hard Rules & Constraints (follow exactly):
- The plan must simulate enterprise cloud-native engineering covering architecture, IaC, CI/CD, security, observability, testing, deployment, and ops.
- **NO application source code** allowed. Produce only configs, manifests, ADRs, IaC, pipeline files, docs, runbooks, test plans, and descriptive steps.
- Use **OpenAPI contract-first** for all external APIs. Use **RFC7807 ProblemDetails** for API errors.
- Use **Terraform** for infra (or a clearly-labeled provider-specific alternative). Use **Helm** or **Kustomize** for Kubernetes manifests. For each provider-specific resource provide a provider-agnostic alternative or equivalent.
- For container images include image signing (Cosign/Sigstore), SBOM generation, and image scanning in the pipeline.
- For every cloud-specific suggestion give a provider-agnostic alternative (AWS <> GCP <> Azure equivalents).
- Each sprint must start with a **2–3 line Sprint Goal** and include **one sprint-level artifact** (ADR, architecture diagram, Terraform module, or equivalent).
- Include realistic budget constraints and business pressure simulation throughout.
- Add vendor evaluation criteria, capacity planning exercises, and technical debt scenarios.
- Include sprint retrospective templates and architectural decision impact assessments.

**Daily output format — EXACTLY** (this is mandatory):

Day X – [Task Title]  
Goal: One-line statement of purpose.
DoD: One-line definition of done with acceptance criteria.
Budget Impact: Estimated cost impact or optimization opportunity.

Steps:
- Declarative step
- Declarative step  
- Declarative step

Deliverables:
- Explicit artifact(s) with exact file paths/names (examples: `terraform/network/main.tf`, `helm/payment/values.yaml`, `.github/workflows/ci.yml`, `docs/ADR-00X.md`, `api/openapi/v1/payments.yaml`, `k8s/manifests/ingress.yaml`, `monitoring/grafana/dashboard.json`, `runbooks/oncall-playbook.md`, `tests/contract/pact/*.json`, etc.)

Troubleshooting Scenario: Brief realistic failure scenario to practice.
Reflection Questions: 2-3 questions to assess understanding and decision rationale.

- Every day MUST produce at least one artifact. If logically none applies, write: "No artifact deliverable today."
- Provide concrete file names/paths for every artifact produced in the Deliverables section.
- When introducing a new cloud/platform concept (e.g., Service Mesh, KEDA, IRSA, VPC endpoints), include a **1–2 line plain-English explanation** (beginner-friendly).
- Keep entries concise, declarative, and actionable. Do not be verbose.
- Tone: senior enterprise cloud architect mentoring a beginner — concise, direct, practical.
- Include a short rationale (1–2 lines) for any optional omission (e.g., "service mesh omitted for simplicity — rationale…").

## Sprint Structure Requirements:
Each sprint must include:
- **Sprint Goal** (2-3 lines)
- **Sprint Retrospective Template** with lessons learned format
- **One major sprint-level artifact** (architecture diagram, major ADR, core Terraform module)
- **Simulated business constraint** (timeline pressure, budget cut, compliance requirement)
- **Vendor evaluation exercise** (comparing 2-3 solutions with decision matrix)
- **Technical debt scenario** with remediation planning

## Coverage expectations (these topics must appear across the 30 days):
- IaC (network/VPC, cluster, DB, IAM, secrets) including Terraform remote state & locking.
- Container image build & signing (Cosign/Sigstore), SBOM, and Dockerfile best practices.
- Managed DB + schema migrations (Flyway or provider equivalent) + backup verification & restore drills.
- Secrets management (Vault / cloud secrets) and secretless patterns (workload identity); CI secrets injection pattern documented.
- Kubernetes: Helm charts, readiness/liveness probes, HPA/VPA, KEDA optional, network policies and private endpoints.
- Service mesh or explicit rationale for omission (include canary analysis automation if mesh used).
- Messaging + Outbox pattern, schema registry, schema evolution policy and CI compatibility checks.
- Auth/Identity (OIDC/JWT), RBAC, least-privilege IAM, OIDC for workload identity, service-account lifecycle.
- Observability: OpenTelemetry, Prometheus, Grafana, Tracing (Jaeger/X-Ray), SLOs/SLIs, alert thresholds, business metrics, and cost dashboards.
- CI/CD + GitOps (ArgoCD/Flux), canary/blue-green strategies, preview environments with TTL and teardown policies, E2E smoke tests after deploy.
- Testing: unit tests, integration (Testcontainers), contract tests, schema compatibility checks, load & chaos testing, performance budgets validation.
- Security: dependency scanning, SBOM, SCA, image scanning, policy-as-code (OPA/Conftest), TLS, supply-chain triage workflow, dependency upgrade policy.
- Ops: runbooks, SLOs/SLIs, alerting, backup & DR drills, on-call playbooks, escalation policy, postmortem automation.
- Governance: ADRs, changelogs, PR templates, conventional commits, license scanning, RACI and repo governance.
- Cost & billing: tagging, rightsizing, budget alerts, preview env teardown policy, service sizing, initial cost estimate template.
- Compliance: GDPR/PII handling, PCI mapping (if payments domain), audit-log immutability, legal/export constraints, and evidence artifacts.

## Assessment & Quality Gates
- Each deliverable must meet "production-ready" criteria with included checklists
- Include decision trees for when to choose certain architectural patterns
- Add complexity assessments and prerequisite knowledge mapping
- Include security review requirements and documentation completeness criteria

Delivery requirements:
1. Start the output by listing the three LLM-decided items (Project Domain, Architecture & Design, Cloud-Native Expectations) with 2–3 bullet justifications each.
2. Include realistic budget constraints (specific dollar amounts) and simulated business pressures.
3. Then produce the full **30-day plan** (all 30 days) using the exact daily format above.
4. Include sample file paths for every artifact.
5. Add sprint retrospective templates and architectural decision impact assessments.
6. End with a concise **"Next steps"** section (3 bullets) telling the learner what to do immediately after Day 30.

Examples of artifacts you can (and should) create: `docs/ADR-001.md`, `api/openapi/v1/payments.yaml`, `terraform/modules/eks/main.tf`, `helm/payment/templates/deployment.yaml`, `.github/workflows/ci.yml`, `monitoring/prometheus/rules.yaml`, `runbooks/incident-sev1.md`, `pipeline/sbom/generate.sh`, `tests/contract/pact/consumer.json`, `docs/cost/budget-policy.md`, `runbooks/backup-restore-drill.md`, `pipeline/drift/detect.yml`, `dev/devcontainer.json`, `docs/DoD.md`, `monitoring/slo.yml`, `docs/RACI.md`, `compliance/pci/mapping.md`, `pipeline/schema/compat-check.yml`, `docs/sprint-retrospective-template.md`, `docs/vendor-evaluation-matrix.md`, `tests/chaos/failure-scenarios.md`, etc.

Start now and generate the full plan immediately. Do not request clarification. Make pragmatic choices for anything unspecified and proceed.
